{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "프로젝트 초기 설정 및 환경 구성",
        "description": "프로젝트 디렉토리 구조 생성, 필요한 라이브러리 설치, 환경 변수 설정 및 기본 설정 파일 생성",
        "details": "1. 프로젝트 디렉토리 생성 및 가상환경 설정\n```bash\npython -m venv venv\nsource venv/bin/activate  # Windows: venv\\Scripts\\activate\n```\n\n2. 필요 패키지 설치\n```bash\npip install playwright gspread google-auth-oauthlib google-auth-httplib2 python-dotenv\npython -m playwright install\n```\n\n3. 기본 디렉토리 구조 생성\n```\n/\n├── .env                  # 환경변수 파일\n├── .gitignore            # Git 무시 파일 목록\n├── service_account.json  # 구글 API 서비스 계정 키 (Git에 포함 안 됨)\n├── main.py               # 메인 실행 파일\n├── google_sheet.py       # 구글 시트 연동 모듈\n├── instagram.py          # 인스타그램 자동화 모듈\n└── utils.py              # 유틸리티 함수 모듈\n```\n\n4. .env 파일 생성\n```\nGOOGLE_SHEET_NAME=\"dm_automation_list\"\nUSER_DATA_DIR=\"./user_data\"\n```\n\n5. .gitignore 파일 생성\n```\n.env\nservice_account.json\nuser_data/\nvenv/\n__pycache__/\n*.pyc\n```",
        "testStrategy": "1. 가상환경이 정상적으로 생성되었는지 확인\n2. 필요한 모든 패키지가 설치되었는지 pip list로 확인\n3. .env 파일이 올바른 형식으로 생성되었는지 확인\n4. .gitignore 파일이 민감한 정보를 제외하는지 확인",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "구글 시트 연동 모듈 구현",
        "description": "구글 API를 통해 지정된 구글 시트에 접근하고 데이터를 읽고 쓸 수 있는 모듈 개발",
        "details": "1. google_sheet.py 파일 생성\n\n```python\nimport gspread\nfrom google.oauth2.service_account import Credentials\nimport os\nfrom dotenv import load_dotenv\nfrom datetime import datetime\n\nload_dotenv()\n\nclass GoogleSheetManager:\n    def __init__(self):\n        # 서비스 계정 인증 설정\n        self.scope = ['https://spreadsheets.google.com/feeds',\n                      'https://www.googleapis.com/auth/drive']\n        self.creds = Credentials.from_service_account_file('service_account.json', scopes=self.scope)\n        self.client = gspread.authorize(self.creds)\n        self.sheet_name = os.getenv('GOOGLE_SHEET_NAME')\n        self.sheet = self.client.open(self.sheet_name).worksheet('dm_automation_list')\n    \n    def get_pending_tasks(self):\n        \"\"\"상태가 PENDING인 모든 행을 가져옴\"\"\"\n        return self.sheet.get_all_records()\n    \n    def get_sent_tasks(self):\n        \"\"\"상태가 SENT인 모든 행을 가져옴\"\"\"\n        all_records = self.sheet.get_all_records()\n        return [record for record in all_records if record['status'] == 'SENT']\n    \n    def update_status(self, row_index, status, timestamp=None, reply=None):\n        \"\"\"특정 행의 상태와 관련 정보 업데이트\"\"\"\n        # 행 인덱스는 1부터 시작하며, 헤더를 고려하여 +2 해야함\n        row = row_index + 2\n        \n        # 상태 업데이트\n        self.sheet.update_cell(row, 3, status)\n        \n        # 타임스탬프 업데이트 (있는 경우)\n        if timestamp:\n            formatted_time = timestamp.strftime(\"%Y-%m-%dT%H:%M:%S+09:00\")\n            if status == 'SENT':\n                self.sheet.update_cell(row, 4, formatted_time)\n            elif status == 'REPLIED':\n                self.sheet.update_cell(row, 6, formatted_time)\n        \n        # 답장 또는 실패 사유 업데이트 (있는 경우)\n        if reply:\n            self.sheet.update_cell(row, 5, reply)\n```",
        "testStrategy": "1. 서비스 계정 인증이 정상적으로 작동하는지 확인\n2. get_pending_tasks() 메서드가 PENDING 상태의 행만 올바르게 반환하는지 확인\n3. get_sent_tasks() 메서드가 SENT 상태의 행만 올바르게 반환하는지 확인\n4. update_status() 메서드가 지정된 행의 상태, 타임스탬프, 답장을 올바르게 업데이트하는지 확인\n5. 예외 상황(시트 접근 권한 없음, 네트워크 오류 등)에 대한 예외 처리가 정상 작동하는지 확인",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "인스타그램 로그인 및 세션 관리 구현",
        "description": "Playwright를 사용하여 인스타그램에 로그인하고 세션을 관리하는 기능 구현",
        "details": "1. instagram.py 파일에 로그인 및 세션 관리 클래스 구현\n\n```python\nfrom playwright.sync_api import sync_playwright\nimport os\nfrom dotenv import load_dotenv\nimport time\nimport random\n\nload_dotenv()\n\nclass InstagramAutomation:\n    def __init__(self):\n        self.user_data_dir = os.getenv('USER_DATA_DIR')\n        self.playwright = None\n        self.browser = None\n        self.context = None\n        self.page = None\n    \n    def start_browser(self):\n        \"\"\"Playwright 브라우저 시작 및 저장된 세션으로 로그인\"\"\"\n        self.playwright = sync_playwright().start()\n        self.browser = self.playwright.chromium.launch(headless=False)\n        \n        # 저장된 사용자 데이터로 컨텍스트 생성 (세션 유지)\n        self.context = self.browser.new_context(user_data_dir=self.user_data_dir)\n        self.page = self.context.new_page()\n        \n        # 인스타그램 메인 페이지 접속\n        self.page.goto('https://www.instagram.com/')\n        \n        # 로그인 상태 확인\n        if 'Login' in self.page.title() or self.page.get_by_role(\"button\", name=\"Log in\").is_visible():\n            raise Exception(\"로그인 세션 만료. 수동 로그인 필요\")\n        \n        return True\n    \n    def close_browser(self):\n        \"\"\"브라우저 종료\"\"\"\n        if self.context:\n            self.context.close()\n        if self.browser:\n            self.browser.close()\n        if self.playwright:\n            self.playwright.stop()\n    \n    def random_delay(self, min_seconds=30, max_seconds=60):\n        \"\"\"랜덤 지연 시간 생성\"\"\"\n        delay = random.uniform(min_seconds, max_seconds)\n        time.sleep(delay)\n```",
        "testStrategy": "1. start_browser() 메서드가 브라우저를 성공적으로 시작하는지 확인\n2. 저장된 세션으로 자동 로그인이 되는지 확인\n3. 세션이 만료된 경우 적절한 예외가 발생하는지 확인\n4. close_browser() 메서드가 브라우저 리소스를 올바르게 해제하는지 확인\n5. random_delay() 메서드가 지정된 범위 내에서 랜덤한 지연 시간을 생성하는지 확인",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "DM 발송 기능 구현",
        "description": "인스타그램 DM을 자동으로 발송하고 결과를 처리하는 기능 구현",
        "details": "1. instagram.py 파일에 DM 발송 메서드 추가\n\n```python\ndef send_dm(self, username, message):\n    \"\"\"특정 사용자에게 DM 발송\"\"\"\n    try:\n        # 메시지 페이지로 이동\n        self.page.goto('https://www.instagram.com/direct/inbox/')\n        time.sleep(2)\n        \n        # 새 메시지 버튼 클릭\n        new_message_button = self.page.get_by_role(\"button\", name=\"New message\")\n        new_message_button.click()\n        time.sleep(2)\n        \n        # 사용자 검색\n        search_input = self.page.get_by_placeholder(\"Search...\")\n        search_input.fill(username)\n        time.sleep(3)\n        \n        # 검색 결과에서 사용자 선택\n        user_option = self.page.get_by_text(username, exact=True).first\n        if not user_option.is_visible():\n            return False, \"User not found\"\n        \n        user_option.click()\n        time.sleep(1)\n        \n        # 다음 버튼 클릭\n        next_button = self.page.get_by_role(\"button\", name=\"Next\")\n        next_button.click()\n        time.sleep(2)\n        \n        # 메시지 입력 및 전송\n        message_input = self.page.get_by_placeholder(\"Message...\")\n        message_input.fill(message)\n        time.sleep(1)\n        \n        send_button = self.page.get_by_role(\"button\", name=\"Send\")\n        send_button.click()\n        time.sleep(2)\n        \n        return True, None\n    \n    except Exception as e:\n        error_message = str(e)\n        if \"Element not found\" in error_message:\n            return False, \"Element not found\"\n        elif \"Message blocked\" in error_message:\n            return False, \"Message blocked\"\n        else:\n            return False, f\"Error: {error_message}\"\n```\n\n2. main.py 파일에 DM 발송 로직 구현\n\n```python\nfrom google_sheet import GoogleSheetManager\nfrom instagram import InstagramAutomation\nfrom datetime import datetime\nimport time\n\ndef send_pending_dms():\n    sheet_manager = GoogleSheetManager()\n    instagram = InstagramAutomation()\n    \n    # PENDING 상태의 작업 가져오기\n    all_records = sheet_manager.get_pending_tasks()\n    pending_tasks = [record for record in all_records if record['status'] == 'PENDING']\n    \n    if not pending_tasks:\n        print(\"발송할 PENDING 메시지가 없습니다.\")\n        return\n    \n    # 하루 최대 발송량 제한\n    daily_limit = 50\n    if len(pending_tasks) > daily_limit:\n        pending_tasks = pending_tasks[:daily_limit]\n    \n    try:\n        # 브라우저 시작\n        instagram.start_browser()\n        \n        # 각 PENDING 작업에 대해 DM 발송\n        for i, task in enumerate(pending_tasks):\n            username = task['username']\n            message = task['message']\n            \n            # 원본 데이터에서의 행 인덱스 찾기\n            row_index = all_records.index(task)\n            \n            # DM 발송 시도\n            success, error_message = instagram.send_dm(username, message)\n            \n            # 결과에 따라 시트 업데이트\n            if success:\n                sheet_manager.update_status(row_index, \"SENT\", datetime.now())\n                print(f\"[성공] {username}에게 메시지 발송 완료\")\n            else:\n                sheet_manager.update_status(row_index, \"FAILED\", None, error_message)\n                print(f\"[실패] {username}: {error_message}\")\n            \n            # 다음 작업 전 랜덤 지연\n            if i < len(pending_tasks) - 1:  # 마지막 작업이 아니면\n                instagram.random_delay()\n    \n    except Exception as e:\n        print(f\"오류 발생: {str(e)}\")\n    \n    finally:\n        # 브라우저 종료\n        instagram.close_browser()\n```",
        "testStrategy": "1. send_dm() 메서드가 유효한 사용자에게 메시지를 성공적으로 보내는지 확인\n2. 존재하지 않는 사용자에게 메시지를 보낼 때 적절한 오류 처리가 되는지 확인\n3. 인스타그램 UI 변경에 대응할 수 있도록 선택자가 올바르게 작동하는지 확인\n4. 메시지 발송 후 구글 시트의 상태가 올바르게 업데이트되는지 확인\n5. 하루 최대 발송량 제한(50개)이 올바르게 적용되는지 확인\n6. 랜덤 지연 시간이 각 메시지 발송 사이에 적용되는지 확인",
        "priority": "high",
        "dependencies": [
          2,
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "DM 답장 수집 기능 구현",
        "description": "발송된 DM에 대한 답장을 자동으로 수집하고 구글 시트에 기록하는 기능 구현",
        "details": "1. instagram.py 파일에 답장 수집 메서드 추가\n\n```python\ndef check_replies(self, username, sent_timestamp):\n    \"\"\"특정 사용자의 DM 답장 확인\"\"\"\n    try:\n        # 메시지 페이지로 이동\n        self.page.goto('https://www.instagram.com/direct/inbox/')\n        time.sleep(3)\n        \n        # 사용자 채팅방 찾기\n        chat_item = self.page.get_by_text(username, exact=True).first\n        if not chat_item.is_visible():\n            return False, \"Chat not found\"\n        \n        chat_item.click()\n        time.sleep(3)\n        \n        # 메시지 컨테이너 찾기\n        message_container = self.page.locator('div[role=\"listbox\"]')\n        \n        # 모든 메시지 요소 가져오기\n        message_elements = message_container.locator('div[role=\"listitem\"]').all()\n        \n        # sent_timestamp 이후의 상대방 메시지 찾기\n        replies = []\n        for msg_elem in message_elements:\n            # 메시지 시간 확인 (인스타그램 UI에 따라 조정 필요)\n            # 여기서는 단순화를 위해 모든 상대방 메시지를 수집\n            if \"them\" in msg_elem.get_attribute(\"aria-label\") or \"their\" in msg_elem.get_attribute(\"aria-label\"):\n                message_text = msg_elem.inner_text()\n                replies.append(message_text)\n        \n        if not replies:\n            return False, \"No replies found\"\n        \n        # 모든 답장을 줄바꿈으로 연결\n        combined_replies = \"\\n\".join(replies)\n        return True, combined_replies\n    \n    except Exception as e:\n        return False, f\"Error: {str(e)}\"\n```\n\n2. main.py 파일에 답장 수집 로직 추가\n\n```python\ndef collect_replies():\n    sheet_manager = GoogleSheetManager()\n    instagram = InstagramAutomation()\n    \n    # SENT 상태의 작업 가져오기\n    sent_tasks = sheet_manager.get_sent_tasks()\n    \n    if not sent_tasks:\n        print(\"수집할 SENT 메시지가 없습니다.\")\n        return\n    \n    try:\n        # 브라우저 시작\n        instagram.start_browser()\n        \n        # 각 SENT 작업에 대해 답장 확인\n        for i, task in enumerate(sent_tasks):\n            username = task['username']\n            sent_timestamp_str = task['sent_timestamp']\n            \n            # 타임스탬프 문자열을 datetime 객체로 변환\n            sent_timestamp = datetime.fromisoformat(sent_timestamp_str.replace('Z', '+00:00'))\n            \n            # 원본 데이터에서의 행 인덱스 찾기\n            all_records = sheet_manager.sheet.get_all_records()\n            row_index = next((i for i, record in enumerate(all_records) \n                              if record['username'] == username and record['status'] == 'SENT'), None)\n            \n            if row_index is None:\n                print(f\"[오류] {username}의 행을 찾을 수 없습니다.\")\n                continue\n            \n            # 답장 확인\n            has_reply, reply_content = instagram.check_replies(username, sent_timestamp)\n            \n            # 답장이 있으면 시트 업데이트\n            if has_reply:\n                sheet_manager.update_status(row_index, \"REPLIED\", datetime.now(), reply_content)\n                print(f\"[수집] {username}의 답장 수집 완료\")\n            \n            # 다음 작업 전 랜덤 지연\n            if i < len(sent_tasks) - 1:  # 마지막 작업이 아니면\n                instagram.random_delay()\n    \n    except Exception as e:\n        print(f\"오류 발생: {str(e)}\")\n    \n    finally:\n        # 브라우저 종료\n        instagram.close_browser()\n```",
        "testStrategy": "1. check_replies() 메서드가 특정 사용자의 DM 채팅방에 접근할 수 있는지 확인\n2. sent_timestamp 이후의 메시지만 올바르게 수집하는지 확인\n3. 여러 개의 답장 메시지를 줄바꿈(\\n)으로 올바르게 결합하는지 확인\n4. 답장이 없는 경우 적절한 결과를 반환하는지 확인\n5. 수집된 답장이 구글 시트에 올바르게 기록되고 상태가 'REPLIED'로 변경되는지 확인\n6. 인스타그램 UI 변경에 대응할 수 있도록 선택자가 올바르게 작동하는지 확인",
        "priority": "high",
        "dependencies": [
          2,
          3,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "메인 실행 로직 및 스케줄러 구현",
        "description": "DM 발송과 답장 수집 기능을 통합하고 주기적으로 실행할 수 있는 스케줄러 구현",
        "details": "1. main.py 파일에 메인 실행 로직 추가\n\n```python\nimport schedule\nimport time\nfrom datetime import datetime\n\ndef main():\n    print(f\"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] 인스타그램 DM 자동화 시작\")\n    \n    # DM 발송 실행\n    print(\"\\n--- DM 발송 작업 시작 ---\")\n    send_pending_dms()\n    print(\"--- DM 발송 작업 완료 ---\\n\")\n    \n    # 잠시 대기 후 답장 수집 실행\n    time.sleep(10)\n    \n    print(\"\\n--- 답장 수집 작업 시작 ---\")\n    collect_replies()\n    print(\"--- 답장 수집 작업 완료 ---\\n\")\n    \n    print(f\"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] 인스타그램 DM 자동화 완료\")\n\n# 스케줄러 설정\ndef setup_scheduler():\n    # 매일 특정 시간에 실행 (예: 오전 10시와 오후 6시)\n    schedule.every().day.at(\"10:00\").do(main)\n    schedule.every().day.at(\"18:00\").do(main)\n    \n    print(\"스케줄러가 설정되었습니다. 프로그램이 실행 중입니다...\")\n    \n    while True:\n        schedule.run_pending()\n        time.sleep(60)  # 1분마다 스케줄 확인\n\nif __name__ == \"__main__\":\n    import argparse\n    \n    parser = argparse.ArgumentParser(description='인스타그램 DM 자동화 및 답장 수집 시스템')\n    parser.add_argument('--now', action='store_true', help='스케줄 무시하고 즉시 실행')\n    parser.add_argument('--send-only', action='store_true', help='DM 발송만 실행')\n    parser.add_argument('--collect-only', action='store_true', help='답장 수집만 실행')\n    \n    args = parser.parse_args()\n    \n    if args.now:\n        main()\n    elif args.send_only:\n        send_pending_dms()\n    elif args.collect_only:\n        collect_replies()\n    else:\n        setup_scheduler()\n```",
        "testStrategy": "1. 메인 실행 로직이 DM 발송과 답장 수집을 순차적으로 올바르게 실행하는지 확인\n2. 스케줄러가 지정된 시간에 작업을 실행하는지 확인\n3. 명령줄 인수(--now, --send-only, --collect-only)가 올바르게 작동하는지 확인\n4. 장시간 실행 시 메모리 누수나 성능 저하가 없는지 확인\n5. 예외 상황 발생 시 전체 프로그램이 중단되지 않고 다음 스케줄에 다시 실행되는지 확인",
        "priority": "medium",
        "dependencies": [
          4,
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "예외 처리 및 로깅 시스템 구현",
        "description": "프로그램 실행 중 발생할 수 있는 다양한 예외 상황을 처리하고 로그를 기록하는 시스템 구현",
        "details": "1. utils.py 파일에 로깅 시스템 구현\n\n```python\nimport logging\nimport os\nfrom datetime import datetime\n\ndef setup_logger():\n    \"\"\"로깅 시스템 설정\"\"\"\n    # 로그 디렉토리 생성\n    if not os.path.exists('logs'):\n        os.makedirs('logs')\n    \n    # 현재 날짜로 로그 파일명 생성\n    log_filename = f\"logs/dm_automation_{datetime.now().strftime('%Y%m%d')}.log\"\n    \n    # 로거 설정\n    logger = logging.getLogger('dm_automation')\n    logger.setLevel(logging.INFO)\n    \n    # 파일 핸들러\n    file_handler = logging.FileHandler(log_filename)\n    file_handler.setLevel(logging.INFO)\n    \n    # 콘솔 핸들러\n    console_handler = logging.StreamHandler()\n    console_handler.setLevel(logging.INFO)\n    \n    # 포맷 설정\n    formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')\n    file_handler.setFormatter(formatter)\n    console_handler.setFormatter(formatter)\n    \n    # 핸들러 추가\n    logger.addHandler(file_handler)\n    logger.addHandler(console_handler)\n    \n    return logger\n```\n\n2. 예외 처리 함수 추가\n\n```python\ndef safe_execution(func, error_message, logger):\n    \"\"\"안전한 함수 실행을 위한 래퍼\"\"\"\n    try:\n        return func()\n    except Exception as e:\n        logger.error(f\"{error_message}: {str(e)}\")\n        return None\n```\n\n3. main.py 파일에 로깅 시스템 통합\n\n```python\nfrom utils import setup_logger, safe_execution\n\n# 로거 설정\nlogger = setup_logger()\n\ndef send_pending_dms():\n    sheet_manager = GoogleSheetManager()\n    instagram = InstagramAutomation()\n    \n    # PENDING 상태의 작업 가져오기\n    all_records = safe_execution(\n        lambda: sheet_manager.get_pending_tasks(),\n        \"구글 시트 데이터 가져오기 실패\",\n        logger\n    )\n    \n    if not all_records:\n        logger.error(\"구글 시트 데이터를 가져올 수 없습니다.\")\n        return\n    \n    pending_tasks = [record for record in all_records if record['status'] == 'PENDING']\n    \n    if not pending_tasks:\n        logger.info(\"발송할 PENDING 메시지가 없습니다.\")\n        return\n    \n    # 하루 최대 발송량 제한\n    daily_limit = 50\n    if len(pending_tasks) > daily_limit:\n        pending_tasks = pending_tasks[:daily_limit]\n        logger.info(f\"발송량이 일일 제한({daily_limit}개)을 초과하여 제한됩니다.\")\n    \n    try:\n        # 브라우저 시작\n        browser_started = safe_execution(\n            lambda: instagram.start_browser(),\n            \"브라우저 시작 실패\",\n            logger\n        )\n        \n        if not browser_started:\n            logger.error(\"브라우저를 시작할 수 없습니다. 프로그램을 종료합니다.\")\n            return\n        \n        # 각 PENDING 작업에 대해 DM 발송\n        for i, task in enumerate(pending_tasks):\n            username = task['username']\n            message = task['message']\n            \n            logger.info(f\"[{i+1}/{len(pending_tasks)}] {username}에게 DM 발송 시도 중...\")\n            \n            # 원본 데이터에서의 행 인덱스 찾기\n            row_index = all_records.index(task)\n            \n            # DM 발송 시도\n            success, error_message = safe_execution(\n                lambda: instagram.send_dm(username, message),\n                f\"{username}에게 DM 발송 실패\",\n                logger\n            )\n            \n            if success is None:  # safe_execution에서 예외 발생\n                continue\n            \n            # 결과에 따라 시트 업데이트\n            if success:\n                update_success = safe_execution(\n                    lambda: sheet_manager.update_status(row_index, \"SENT\", datetime.now()),\n                    f\"{username}의 상태 업데이트 실패\",\n                    logger\n                )\n                \n                if update_success is not None:\n                    logger.info(f\"[성공] {username}에게 메시지 발송 완료\")\n            else:\n                update_success = safe_execution(\n                    lambda: sheet_manager.update_status(row_index, \"FAILED\", None, error_message),\n                    f\"{username}의 상태 업데이트 실패\",\n                    logger\n                )\n                \n                if update_success is not None:\n                    logger.warning(f\"[실패] {username}: {error_message}\")\n            \n            # 다음 작업 전 랜덤 지연\n            if i < len(pending_tasks) - 1:  # 마지막 작업이 아니면\n                delay_time = instagram.random_delay()\n                logger.info(f\"{delay_time:.1f}초 대기 중...\")\n    \n    except Exception as e:\n        logger.error(f\"예상치 못한 오류 발생: {str(e)}\")\n    \n    finally:\n        # 브라우저 종료\n        safe_execution(\n            lambda: instagram.close_browser(),\n            \"브라우저 종료 실패\",\n            logger\n        )\n```",
        "testStrategy": "1. 로깅 시스템이 파일과 콘솔에 모두 로그를 기록하는지 확인\n2. 다양한 로그 레벨(INFO, WARNING, ERROR)이 올바르게 기록되는지 확인\n3. safe_execution 함수가 예외를 올바르게 포착하고 로깅하는지 확인\n4. 예외 발생 시 프로그램이 완전히 중단되지 않고 계속 실행되는지 확인\n5. 로그 파일이 날짜별로 올바르게 생성되는지 확인\n6. 중요한 오류(브라우저 시작 실패 등)가 발생했을 때 적절한 조치가 취해지는지 확인",
        "priority": "medium",
        "dependencies": [
          4,
          5,
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "인스타그램 UI 변경 대응 시스템 구현",
        "description": "인스타그램 웹 UI 변경에 유연하게 대응할 수 있는 선택자 관리 시스템 구현",
        "details": "1. instagram.py 파일에 선택자 관리 시스템 추가\n\n```python\nclass InstagramSelectors:\n    \"\"\"인스타그램 UI 선택자 관리 클래스\"\"\"\n    def __init__(self):\n        # 기본 선택자 설정\n        self.selectors = {\n            # 메시지 관련 선택자\n            'new_message_button': 'button[aria-label=\"New message\"]',\n            'search_input': 'input[placeholder=\"Search...\"]',\n            'next_button': 'button:has-text(\"Next\")',\n            'message_input': 'div[aria-label=\"Message\"] p',\n            'send_button': 'button:has-text(\"Send\")',\n            \n            # 채팅방 관련 선택자\n            'message_container': 'div[role=\"listbox\"]',\n            'message_item': 'div[role=\"listitem\"]',\n            \n            # 로그인 관련 선택자\n            'login_button': 'button:has-text(\"Log in\")',\n        }\n        \n        # 대체 선택자 설정 (UI 변경 시 사용)\n        self.alternative_selectors = {\n            'new_message_button': ['button[aria-label=\"New message\"]', 'svg[aria-label=\"New message\"]'],\n            'search_input': ['input[placeholder=\"Search...\"]', 'input[aria-label=\"Search\"]'],\n            'next_button': ['button:has-text(\"Next\")', 'div[role=\"button\"]:has-text(\"Next\")'],\n            'message_input': ['div[aria-label=\"Message\"] p', 'div[contenteditable=\"true\"]'],\n            'send_button': ['button:has-text(\"Send\")', 'svg[aria-label=\"Send\"]'],\n        }\n    \n    def get_selector(self, name, page=None):\n        \"\"\"선택자 이름으로 실제 선택자 문자열 반환\"\"\"\n        # 기본 선택자 반환\n        selector = self.selectors.get(name)\n        \n        # 페이지가 제공되면 선택자 유효성 검사\n        if page and selector:\n            if not page.locator(selector).count():\n                # 기본 선택자가 작동하지 않으면 대체 선택자 시도\n                alternatives = self.alternative_selectors.get(name, [])\n                for alt_selector in alternatives:\n                    if page.locator(alt_selector).count():\n                        # 작동하는 대체 선택자를 찾으면 기본값 업데이트\n                        self.selectors[name] = alt_selector\n                        return alt_selector\n        \n        return selector\n```\n\n2. InstagramAutomation 클래스 수정\n\n```python\nclass InstagramAutomation:\n    def __init__(self):\n        self.user_data_dir = os.getenv('USER_DATA_DIR')\n        self.playwright = None\n        self.browser = None\n        self.context = None\n        self.page = None\n        self.selectors = InstagramSelectors()\n    \n    # 선택자 사용 예시\n    def send_dm(self, username, message):\n        \"\"\"특정 사용자에게 DM 발송\"\"\"\n        try:\n            # 메시지 페이지로 이동\n            self.page.goto('https://www.instagram.com/direct/inbox/')\n            time.sleep(2)\n            \n            # 새 메시지 버튼 클릭 (선택자 관리 시스템 사용)\n            new_message_selector = self.selectors.get_selector('new_message_button', self.page)\n            if not new_message_selector:\n                return False, \"New message button not found\"\n            \n            self.page.locator(new_message_selector).click()\n            time.sleep(2)\n            \n            # 사용자 검색 (선택자 관리 시스템 사용)\n            search_selector = self.selectors.get_selector('search_input', self.page)\n            if not search_selector:\n                return False, \"Search input not found\"\n            \n            self.page.locator(search_selector).fill(username)\n            time.sleep(3)\n            \n            # 나머지 코드도 동일하게 선택자 관리 시스템 사용\n            # ...\n        \n        except Exception as e:\n            return False, f\"Error: {str(e)}\"\n```",
        "testStrategy": "1. 기본 선택자가 올바르게 작동하는지 확인\n2. 기본 선택자가 작동하지 않을 때 대체 선택자가 자동으로 시도되는지 확인\n3. 작동하는 선택자를 찾으면 기본값이 업데이트되는지 확인\n4. 모든 선택자가 작동하지 않을 때 적절한 오류 메시지가 반환되는지 확인\n5. 인스타그램 UI를 의도적으로 변경한 테스트 환경에서 시스템이 올바르게 대응하는지 확인",
        "priority": "medium",
        "dependencies": [
          3,
          4,
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "성능 최적화 및 안정성 개선",
        "description": "프로그램의 성능을 최적화하고 장시간 실행 시 안정성을 개선하는 기능 구현",
        "details": "1. 성능 최적화를 위한 utils.py 파일에 함수 추가\n\n```python\nimport psutil\nimport gc\nimport time\n\ndef optimize_memory():\n    \"\"\"메모리 사용량 최적화\"\"\"\n    # 가비지 컬렉션 강제 실행\n    gc.collect()\n    \n    # 현재 프로세스의 메모리 사용량 반환\n    process = psutil.Process(os.getpid())\n    memory_info = process.memory_info()\n    return memory_info.rss / 1024 / 1024  # MB 단위로 반환\n\ndef monitor_performance(logger, interval=3600):\n    \"\"\"주기적으로 성능 모니터링 및 최적화\"\"\"\n    last_check = time.time()\n    \n    def check_now():\n        nonlocal last_check\n        current_time = time.time()\n        \n        if current_time - last_check >= interval:\n            memory_usage = optimize_memory()\n            logger.info(f\"성능 최적화 완료: 현재 메모리 사용량 {memory_usage:.2f} MB\")\n            last_check = current_time\n    \n    return check_now\n```\n\n2. 안정성 개선을 위한 재시도 메커니즘 구현\n\n```python\ndef retry_operation(operation, max_retries=3, delay=5, backoff=2, exceptions=(Exception,)):\n    \"\"\"작업 실패 시 재시도 메커니즘\"\"\"\n    retries = 0\n    while retries < max_retries:\n        try:\n            return operation()\n        except exceptions as e:\n            retries += 1\n            if retries == max_retries:\n                raise e\n            \n            # 지수 백오프 적용\n            sleep_time = delay * (backoff ** (retries - 1))\n            time.sleep(sleep_time)\n```\n\n3. main.py 파일에 성능 최적화 및 안정성 개선 기능 통합\n\n```python\nfrom utils import setup_logger, safe_execution, optimize_memory, monitor_performance, retry_operation\n\n# 로거 설정\nlogger = setup_logger()\n\n# 성능 모니터링 함수 설정\ncheck_performance = monitor_performance(logger)\n\ndef send_pending_dms():\n    # 시작 전 메모리 최적화\n    memory_usage = optimize_memory()\n    logger.info(f\"작업 시작 전 메모리 사용량: {memory_usage:.2f} MB\")\n    \n    sheet_manager = GoogleSheetManager()\n    instagram = InstagramAutomation()\n    \n    # 재시도 메커니즘을 적용한 구글 시트 데이터 가져오기\n    all_records = retry_operation(\n        lambda: sheet_manager.get_pending_tasks(),\n        max_retries=3,\n        exceptions=(gspread.exceptions.APIError,)\n    )\n    \n    # 나머지 코드...\n    \n    try:\n        # 브라우저 시작\n        browser_started = retry_operation(\n            lambda: instagram.start_browser(),\n            max_retries=2\n        )\n        \n        # 각 PENDING 작업에 대해 DM 발송\n        for i, task in enumerate(pending_tasks):\n            # 주기적으로 성능 체크\n            check_performance()\n            \n            # 나머지 코드...\n    \n    finally:\n        # 작업 완료 후 메모리 최적화\n        memory_usage = optimize_memory()\n        logger.info(f\"작업 완료 후 메모리 사용량: {memory_usage:.2f} MB\")\n```",
        "testStrategy": "1. 장시간 실행 시 메모리 누수가 발생하지 않는지 확인\n2. optimize_memory() 함수가 메모리 사용량을 효과적으로 줄이는지 확인\n3. monitor_performance() 함수가 지정된 간격으로 성능 최적화를 수행하는지 확인\n4. retry_operation() 함수가 일시적인 오류에 대해 지정된 횟수만큼 재시도하는지 확인\n5. 지수 백오프가 올바르게 적용되는지 확인\n6. 재시도 후에도 작업이 실패하면 적절한 예외가 발생하는지 확인",
        "priority": "low",
        "dependencies": [
          6,
          7
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "사용자 매뉴얼 및 배포 준비",
        "description": "프로그램 사용 방법을 설명하는 매뉴얼 작성 및 배포를 위한 준비 작업 수행",
        "details": "1. README.md 파일 작성\n\n```markdown\n# 인스타그램 DM 자동화 및 답장 수집 시스템 (v2.0)\n\n## 소개\n이 프로젝트는 구글 시트에 정의된 타겟 목록을 기반으로 인스타그램 DM을 자동으로 발송하고, 수신된 답장을 수집하여 구글 시트에 체계적으로 업데이트하는 자동화 시스템입니다.\n\n## 주요 기능\n- 구글 시트에서 발송 대상 필터링 및 DM 자동 발송\n- 발송 결과 및 상태 실시간 업데이트\n- DM 답장 자동 수집 및 구글 시트 기록\n- 안정적인 예외 처리 및 로깅 시스템\n- 인스타그램 UI 변경에 대응하는 유연한 선택자 관리\n\n## 설치 방법\n\n### 필수 요구사항\n- Python 3.10 이상\n- 구글 클라우드 서비스 계정 및 API 키\n- 인스타그램 계정\n\n### 설치 단계\n1. 저장소 클론\n```bash\ngit clone https://github.com/username/instagram-dm-automation.git\ncd instagram-dm-automation\n```\n\n2. 가상환경 생성 및 활성화\n```bash\npython -m venv venv\nsource venv/bin/activate  # Windows: venv\\Scripts\\activate\n```\n\n3. 필요 패키지 설치\n```bash\npip install -r requirements.txt\npython -m playwright install\n```\n\n4. 환경 설정\n   - `.env.example` 파일을 `.env`로 복사하고 필요한 값 설정\n   - 구글 서비스 계정 키 파일(`service_account.json`)을 프로젝트 루트에 배치\n\n## 사용 방법\n\n### 구글 시트 준비\n1. 구글 시트 생성 및 `dm_automation_list` 시트 추가\n2. 다음 열 추가: username, message, status, sent_timestamp, reply, replied_timestamp\n3. 서비스 계정 이메일에 시트 편집 권한 부여\n\n### 인스타그램 로그인 세션 준비\n```bash\npython setup_session.py\n```\n- 브라우저가 열리면 인스타그램에 수동으로 로그인\n- 로그인 후 브라우저를 닫으면 세션이 저장됨\n\n### 프로그램 실행\n\n#### 즉시 실행\n```bash\npython main.py --now\n```\n\n#### DM 발송만 실행\n```bash\npython main.py --send-only\n```\n\n#### 답장 수집만 실행\n```bash\npython main.py --collect-only\n```\n\n#### 스케줄러 모드로 실행\n```bash\npython main.py\n```\n- 기본적으로 매일 오전 10시와 오후 6시에 실행됨\n\n## 주의사항\n- 인스타그램 자동화는 서비스 약관에 위배될 수 있으며, 계정 제한이나 정지의 위험이 있습니다.\n- 하루 최대 발송량은 50개로 제한되어 있습니다.\n- 각 메시지 사이에는 30-60초의 랜덤한 지연 시간이 적용됩니다.\n\n## 문제 해결\n- 로그 파일은 `logs` 디렉토리에 저장됩니다.\n- 로그인 세션이 만료된 경우 `setup_session.py`를 다시 실행하세요.\n- 인스타그램 UI가 변경되어 오류가 발생하면 개발자에게 문의하세요.\n```\n\n2. requirements.txt 파일 생성\n\n```\nplaywright==1.39.0\ngspread==5.12.0\ngoogle-auth-oauthlib==1.1.0\ngoogle-auth-httplib2==0.1.1\npython-dotenv==1.0.0\npsutil==5.9.6\nschedule==1.2.1\n```\n\n3. setup_session.py 파일 생성\n\n```python\nfrom playwright.sync_api import sync_playwright\nimport os\nfrom dotenv import load_dotenv\nimport time\n\nload_dotenv()\n\ndef setup_instagram_session():\n    \"\"\"인스타그램 로그인 세션 설정\"\"\"\n    user_data_dir = os.getenv('USER_DATA_DIR', './user_data')\n    \n    # 사용자 데이터 디렉토리 생성\n    if not os.path.exists(user_data_dir):\n        os.makedirs(user_data_dir)\n    \n    with sync_playwright() as playwright:\n        browser = playwright.chromium.launch(headless=False)\n        context = browser.new_context(user_data_dir=user_data_dir)\n        page = context.new_page()\n        \n        # 인스타그램 로그인 페이지로 이동\n        page.goto('https://www.instagram.com/accounts/login/')\n        \n        print(\"\\n\" + \"=\" * 50)\n        print(\"인스타그램에 수동으로 로그인하세요.\")\n        print(\"로그인 후 메인 페이지가 로드될 때까지 기다려 주세요.\")\n        print(\"그런 다음 이 콘솔에서 Enter 키를 눌러 세션을 저장하세요.\")\n        print(\"=\" * 50 + \"\\n\")\n        \n        input(\"로그인 완료 후 Enter 키를 누르세요...\")\n        \n        # 로그인 상태 확인\n        if 'Login' in page.title() or page.get_by_role(\"button\", name=\"Log in\").is_visible():\n            print(\"\\n[오류] 로그인이 완료되지 않았습니다. 다시 시도하세요.\")\n        else:\n            print(\"\\n[성공] 로그인 세션이 저장되었습니다.\")\n        \n        # 브라우저 종료\n        context.close()\n        browser.close()\n\nif __name__ == \"__main__\":\n    setup_instagram_session()\n```\n\n4. .env.example 파일 생성\n\n```\n# 연동할 구글 시트의 이름\nGOOGLE_SHEET_NAME=\"dm_automation_list\"\n\n# 인스타그램 로그인 세션 저장 경로\nUSER_DATA_DIR=\"./user_data\"\n```",
        "testStrategy": "1. README.md 파일이 모든 필수 정보(설치 방법, 사용 방법, 주의사항 등)를 포함하는지 확인\n2. requirements.txt 파일이 모든 필요한 패키지와 올바른 버전을 포함하는지 확인\n3. setup_session.py 스크립트가 인스타그램 로그인 세션을 올바르게 설정하는지 확인\n4. .env.example 파일이 필요한 모든 환경 변수를 포함하는지 확인\n5. 전체 프로젝트 구조가 일관되고 사용하기 쉬운지 확인\n6. 초보자도 매뉴얼을 따라 쉽게 설치하고 사용할 수 있는지 확인",
        "priority": "low",
        "dependencies": [
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-07-09T06:24:17.342Z",
      "updated": "2025-07-09T06:24:17.343Z",
      "description": "Tasks for master context"
    }
  }
}